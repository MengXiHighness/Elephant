
///<summary>
/// Copyright (c) 2011-2015 上海迪爱斯通信设备有限公司
/// 作  者：姜宁
/// 时  间：2013-11-13 11:13:09
/// 描  述：线程安全的Dictionary类
///</summary>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace DS.AFP.Common.Core
{
    /// <summary>
    /// 线程安全的Dictionary
    /// </summary>
    /// <typeparam name="TKey"></typeparam>
    /// <typeparam name="TValue"></typeparam>
	[Serializable]
	public class ThreadSafeDictionary<TKey, TValue> : IDictionary<TKey, TValue>
	{
		private object _syncRoot;

		private readonly IDictionary<TKey, TValue> dictionary;

		public ThreadSafeDictionary(IDictionary<TKey, TValue> dictionary)
		{
			this.dictionary = dictionary;
		}

		public object SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}

				return _syncRoot;
			}
		}

		#region IDictionary<TKey,TValue> Members

		public bool ContainsKey(TKey key)
		{
			return dictionary.ContainsKey(key);
		}

		public void Add(TKey key, TValue value)
		{
			lock (SyncRoot)
			{
				dictionary.Add(key, value);
			}
		}

		public bool Remove(TKey key)
		{
			lock (SyncRoot)
			{
				return dictionary.Remove(key);
			}
		}

		public bool TryGetValue(TKey key, out TValue value)
		{
			return dictionary.TryGetValue(key, out value);
		}

		public TValue this[TKey key]
		{
			get { return dictionary[key]; }
			set
			{
				lock (SyncRoot)
				{
					dictionary[key] = value;
				}
			}
		}

		public ICollection<TKey> Keys
		{
			get
			{
				lock (SyncRoot)
				{
					return dictionary.Keys;
				}
			}
		}

		public ICollection<TValue> Values
		{
			get
			{
				lock (SyncRoot)
				{
					return dictionary.Values;
				}
			}
		}

		#endregion

		#region ICollection<KeyValuePair<TKey,TValue>> Members

        /// <summary>
        /// 在 IDictionary 对象中添加一个带有所提供的键和值的元素。
        /// </summary>
        /// <param name="item"></param>
		public void Add(KeyValuePair<TKey, TValue> item)
		{
			lock (SyncRoot)
			{
				dictionary.Add(item);
			}
		}

        /// <summary>
        /// 从 IDictionary 对象中移除所有元素。
        /// </summary>
		public void Clear()
		{
			lock (SyncRoot)
			{
				dictionary.Clear();
			}
		}

        /// <summary>
        /// 确定 IDictionary 对象是否包含具有指定键的元素。
        /// </summary>
        /// <param name="item">要在 IDictionary 对象中定位的对象</param>
        /// <returns>如果 IDictionary 包含带有该键的元素，则为 true；否则为 false</returns>
		public bool Contains(KeyValuePair<TKey, TValue> item)
		{
			return dictionary.Contains(item);
		}

        /// <summary>
        /// 从特定的 Array 索引处开始，将 ICollection 的元素复制到一个 Array 中。 
        /// </summary>
        /// <param name="array">作为从 ICollection 复制的元素的目标位置的一维 Array。Array 必须具有从零开始的索引</param>
        /// <param name="arrayIndex">array 中从零开始的索引，在此处开始复制</param>
		public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
		{
			lock (SyncRoot)
			{
				dictionary.CopyTo(array, arrayIndex);
			}
		}

        /// <summary>
        /// 从 IDictionary 对象中移除带有指定键的元素
        /// </summary>
        /// <param name="item">要移除的元素的对象</param>
		public bool Remove(KeyValuePair<TKey, TValue> item)
		{
			lock (SyncRoot)
			{
				return dictionary.Remove(item);
			}
		}

		public int Count
		{
			get { return dictionary.Count; }
		}

		public bool IsReadOnly
		{
			get { return false; }
		}

		#endregion

		#region IEnumerable<KeyValuePair<TKey,TValue>> Members

		IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
		{
			// In a multi thread environment the dictionary can be changed by another 
			// thread than the actual that asking for a enumerator.
			// The Dictionary<K,V> create a new KeyValuePair for each iteration so....
			// we can create a snapshot for the thread preventing InvalidOperationException when
			// another thread change the version of the dictionary.
			lock (SyncRoot)
			{
				KeyValuePair<TKey, TValue>[] pairArray = new KeyValuePair<TKey, TValue>[dictionary.Count];
				dictionary.CopyTo(pairArray, 0);
				return Array.AsReadOnly(pairArray).GetEnumerator();
			}
		}

		#endregion

		#region IEnumerable Members

		public IEnumerator GetEnumerator()
		{
			return ((IEnumerable<KeyValuePair<TKey, TValue>>) this).GetEnumerator();
		}

		#endregion
	}
}